#lang Racket
;(filter odd? (list 1 2 3 4 5))
;accumulate + 0 (list 1 2 3 4 5)
;(enumerate-interval 2 7)
;(accumulate + 0 (list 1 2 3 4 5))
;(horner-eval 2 (list 1 3 0 5 0 1))
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (-  x 0))        
        )
  )
(define (square x) (* x x))

(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ( (not (pair? tree))
          (if (odd? tree) (square tree) 0)
          )
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))
                 )))      
  )
(define (filter predicate sequence)
  (cond ((null? sequence) null)
        ((predicate (car sequence))

         (cons (car sequence)
               (filter predicate (cdr sequence))
               )
         )
        (else (filter predicate (cdr sequence)))
        )
  
  )

(define (enumerate-interval low high)
  (if (> low high)
      null
      (cons low (enumerate-interval (+ low 1) high))
      )
  )
(define x (cons (list 1 2) (list 3 4)))
(define (count-leaves2 x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves2 (car x))
                 (count-leaves2 (cdr x))
                 ))
        )
  )
;map映射
(define (map p items)
  (if (null? items)
      null
      (cons (p (car items))
            (map p (cdr items)))
      )
  )
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence))
          )
      )
  )
;count-leaves重新定义

(define (length2 sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence)
  )
;用Horner规则求多项式的值
;this-coeff系数
(define duo (list 1 3 0 5 0 1))
(define (horner-eval x confficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
               ; (+ (+ this-coeff (* x  (if (= (length2  confficient-sequence) 1) 0 this-coeff )) )  higher-terms)
               ; (+  (if (= (length2  confficient-sequence)  higher-terms) this-coeff (* x this-coeff ) )  higher-terms)
               (+ this-coeff ( * x higher-terms))
                )           
              0
             confficient-sequence)
  )

(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1)
            (append (cdr list1) list2 )
            )
      )
  )
(define (append2 seq1 seq2)
  (accumulate cons seq2 seq1)
  )
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))
      )
  )



