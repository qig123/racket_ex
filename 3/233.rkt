#lang Racket
;(filter odd? (list 1 2 3 4 5))
;accumulate + 0 (list 1 2 3 4 5)
;(enumerate-interval 2 7)
;(accumulate + 0 (list 1 2 3 4 5))
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (-  x 0))        
        )
  )
(define (square x) (* x x))

(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ( (not (pair? tree))
          (if (odd? tree) (square tree) 0)
          )
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))
                 )))      
  )
(define (filter predicate sequence)
  (cond ((null? sequence) null)
        ((predicate (car sequence))

         (cons (car sequence)
               (filter predicate (cdr sequence))
               )
         )
        (else (filter predicate (cdr sequence)))
        )
  
  )

(define (enumerate-interval low high)
  (if (> low high)
      null
      (cons low (enumerate-interval (+ low 1) high))
      )
  )
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence))
          )
      )
  )
(define (map p items)
  (if (null? items)
      null
      (cons (p (car items))
            (map p (cdr items)))
      )
  )
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1)
            (append (cdr list1) list2 )
            )
      )
  )
(define (append2 seq1 seq2)
  (accumulate cons seq2 seq1)
  )
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))
      )
  )
(define (length2 sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence)
  )


