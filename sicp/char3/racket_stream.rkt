#lang Racket
(define (memo-proc proc)
  (let ((already-run? #f) (result #f))
    (lambda ()
      (if already-run?
          result
          (begin (set! result (proc))
                 (set! already-run? #t)
                 result
                 )))))
(define-syntax-rule (delay exp)
  (memo-proc (lambda () exp))
  )
(define-syntax-rule (cons-stream a b)
  (cons a (delay b))
  )
(define (stream-car x) (car x))
(define (stream-cdr x) (force (cdr x)))
(define (force delayed-object)
  (delayed-object))
(define (stream-null? stream) (null? stream))
(define (stream-filter pred stream)
  (cond
    ((stream-null? stream) null)
    ((pred (stream-car stream))
     (cons-stream (stream-car stream)
                  (stream-filter pred (stream-cdr stream))
                  )
     )
    (else
     (stream-filter pred (stream-cdr stream))
     )
    )
  )
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))
      )
  )
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1)))
  )
(define integers (integers-starting-from 1))
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x)
                   (not (divisible? x 7))
                   ) integers
  ))